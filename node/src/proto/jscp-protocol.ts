// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v5.28.2
// source: jscp-protocol.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "kr.jclab.jscp.payload";

/** AEAD Cipher Algorithm */
export enum CipherAlgorithm {
  CipherUnknown = 0,
  CipherAesGcm = 1,
  UNRECOGNIZED = -1,
}

export function cipherAlgorithmFromJSON(object: any): CipherAlgorithm {
  switch (object) {
    case 0:
    case "CipherUnknown":
      return CipherAlgorithm.CipherUnknown;
    case 1:
    case "CipherAesGcm":
      return CipherAlgorithm.CipherAesGcm;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CipherAlgorithm.UNRECOGNIZED;
  }
}

export function cipherAlgorithmToJSON(object: CipherAlgorithm): string {
  switch (object) {
    case CipherAlgorithm.CipherUnknown:
      return "CipherUnknown";
    case CipherAlgorithm.CipherAesGcm:
      return "CipherAesGcm";
    case CipherAlgorithm.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SignatureAlgorithm {
  SignatureUnknown = 0,
  SignatureX509 = 1,
  SignatureEd25519 = 2,
  UNRECOGNIZED = -1,
}

export function signatureAlgorithmFromJSON(object: any): SignatureAlgorithm {
  switch (object) {
    case 0:
    case "SignatureUnknown":
      return SignatureAlgorithm.SignatureUnknown;
    case 1:
    case "SignatureX509":
      return SignatureAlgorithm.SignatureX509;
    case 2:
    case "SignatureEd25519":
      return SignatureAlgorithm.SignatureEd25519;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SignatureAlgorithm.UNRECOGNIZED;
  }
}

export function signatureAlgorithmToJSON(object: SignatureAlgorithm): string {
  switch (object) {
    case SignatureAlgorithm.SignatureUnknown:
      return "SignatureUnknown";
    case SignatureAlgorithm.SignatureX509:
      return "SignatureX509";
    case SignatureAlgorithm.SignatureEd25519:
      return "SignatureEd25519";
    case SignatureAlgorithm.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DHAlgorithm {
  DHUnknown = 0,
  DHX25519 = 1,
  UNRECOGNIZED = -1,
}

export function dHAlgorithmFromJSON(object: any): DHAlgorithm {
  switch (object) {
    case 0:
    case "DHUnknown":
      return DHAlgorithm.DHUnknown;
    case 1:
    case "DHX25519":
      return DHAlgorithm.DHX25519;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DHAlgorithm.UNRECOGNIZED;
  }
}

export function dHAlgorithmToJSON(object: DHAlgorithm): string {
  switch (object) {
    case DHAlgorithm.DHUnknown:
      return "DHUnknown";
    case DHAlgorithm.DHX25519:
      return "DHX25519";
    case DHAlgorithm.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PayloadType {
  PayloadUnknown = 0,
  PayloadHello = 1,
  /** PayloadHelloWithChangeAlgorithm - Requests a different algorithm to be used. SymmetricState must be reset. */
  PayloadHelloWithChangeAlgorithm = 2,
  UNRECOGNIZED = -1,
}

export function payloadTypeFromJSON(object: any): PayloadType {
  switch (object) {
    case 0:
    case "PayloadUnknown":
      return PayloadType.PayloadUnknown;
    case 1:
    case "PayloadHello":
      return PayloadType.PayloadHello;
    case 2:
    case "PayloadHelloWithChangeAlgorithm":
      return PayloadType.PayloadHelloWithChangeAlgorithm;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PayloadType.UNRECOGNIZED;
  }
}

export function payloadTypeToJSON(object: PayloadType): string {
  switch (object) {
    case PayloadType.PayloadUnknown:
      return "PayloadUnknown";
    case PayloadType.PayloadHello:
      return "PayloadHello";
    case PayloadType.PayloadHelloWithChangeAlgorithm:
      return "PayloadHelloWithChangeAlgorithm";
    case PayloadType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SignaturePublicKey {
  algorithm: SignatureAlgorithm;
  data: Uint8Array;
}

export interface SignaturePrivateKey {
  algorithm: SignatureAlgorithm;
  data: Uint8Array;
}

export interface DHPublicKey {
  algorithm: DHAlgorithm;
  data: Uint8Array;
}

export interface Payload {
  payloadType: PayloadType;
  data: Uint8Array;
}

export interface HelloSigned {
  /** Support DH Algorithms */
  supportDh: DHAlgorithm[];
  /** Support Cipher Algorithms */
  supportCipher: CipherAlgorithm[];
  cipherAlgorithm: CipherAlgorithm;
  /** hello_02: MixHash */
  publicKey:
    | SignaturePublicKey
    | undefined;
  /** hello_03: MixHash or MixKey */
  ephemeralKey:
    | DHPublicKey
    | undefined;
  /** hello_04: EncryptAndMixHash */
  additional: Uint8Array;
}

export interface HelloSignedBytes {
  supportDh: DHAlgorithm[];
  supportCipher: CipherAlgorithm[];
  cipherAlgorithm: CipherAlgorithm;
  /** SignaturePublicKey */
  publicKey: Uint8Array;
  /** DHPublicKey */
  ephemeralKey: Uint8Array;
  additional: Uint8Array;
}

export interface Hello {
  /** hello_01: MixHash(version as little-endian) */
  version: number;
  /** marshaled HelloSigned */
  signed:
    | HelloSigned
    | undefined;
  /** optional signature. signed by Sender's static key */
  signature: Uint8Array;
}

export interface HelloBytes {
  version: number;
  /** marshaled HelloSigned */
  signed: Uint8Array;
  /** hello_05: MixHash */
  signature: Uint8Array;
}

function createBaseSignaturePublicKey(): SignaturePublicKey {
  return { algorithm: 0, data: new Uint8Array(0) };
}

export const SignaturePublicKey: MessageFns<SignaturePublicKey> = {
  encode(message: SignaturePublicKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algorithm !== 0) {
      writer.uint32(8).int32(message.algorithm);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignaturePublicKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignaturePublicKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.algorithm = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignaturePublicKey {
    return {
      algorithm: isSet(object.algorithm) ? signatureAlgorithmFromJSON(object.algorithm) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: SignaturePublicKey): unknown {
    const obj: any = {};
    if (message.algorithm !== 0) {
      obj.algorithm = signatureAlgorithmToJSON(message.algorithm);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignaturePublicKey>, I>>(base?: I): SignaturePublicKey {
    return SignaturePublicKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignaturePublicKey>, I>>(object: I): SignaturePublicKey {
    const message = createBaseSignaturePublicKey();
    message.algorithm = object.algorithm ?? 0;
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSignaturePrivateKey(): SignaturePrivateKey {
  return { algorithm: 0, data: new Uint8Array(0) };
}

export const SignaturePrivateKey: MessageFns<SignaturePrivateKey> = {
  encode(message: SignaturePrivateKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algorithm !== 0) {
      writer.uint32(8).int32(message.algorithm);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignaturePrivateKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignaturePrivateKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.algorithm = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignaturePrivateKey {
    return {
      algorithm: isSet(object.algorithm) ? signatureAlgorithmFromJSON(object.algorithm) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: SignaturePrivateKey): unknown {
    const obj: any = {};
    if (message.algorithm !== 0) {
      obj.algorithm = signatureAlgorithmToJSON(message.algorithm);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignaturePrivateKey>, I>>(base?: I): SignaturePrivateKey {
    return SignaturePrivateKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignaturePrivateKey>, I>>(object: I): SignaturePrivateKey {
    const message = createBaseSignaturePrivateKey();
    message.algorithm = object.algorithm ?? 0;
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDHPublicKey(): DHPublicKey {
  return { algorithm: 0, data: new Uint8Array(0) };
}

export const DHPublicKey: MessageFns<DHPublicKey> = {
  encode(message: DHPublicKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algorithm !== 0) {
      writer.uint32(8).int32(message.algorithm);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DHPublicKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDHPublicKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.algorithm = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DHPublicKey {
    return {
      algorithm: isSet(object.algorithm) ? dHAlgorithmFromJSON(object.algorithm) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: DHPublicKey): unknown {
    const obj: any = {};
    if (message.algorithm !== 0) {
      obj.algorithm = dHAlgorithmToJSON(message.algorithm);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DHPublicKey>, I>>(base?: I): DHPublicKey {
    return DHPublicKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DHPublicKey>, I>>(object: I): DHPublicKey {
    const message = createBaseDHPublicKey();
    message.algorithm = object.algorithm ?? 0;
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBasePayload(): Payload {
  return { payloadType: 0, data: new Uint8Array(0) };
}

export const Payload: MessageFns<Payload> = {
  encode(message: Payload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payloadType !== 0) {
      writer.uint32(8).int32(message.payloadType);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Payload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.payloadType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Payload {
    return {
      payloadType: isSet(object.payloadType) ? payloadTypeFromJSON(object.payloadType) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: Payload): unknown {
    const obj: any = {};
    if (message.payloadType !== 0) {
      obj.payloadType = payloadTypeToJSON(message.payloadType);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Payload>, I>>(base?: I): Payload {
    return Payload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Payload>, I>>(object: I): Payload {
    const message = createBasePayload();
    message.payloadType = object.payloadType ?? 0;
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseHelloSigned(): HelloSigned {
  return {
    supportDh: [],
    supportCipher: [],
    cipherAlgorithm: 0,
    publicKey: undefined,
    ephemeralKey: undefined,
    additional: new Uint8Array(0),
  };
}

export const HelloSigned: MessageFns<HelloSigned> = {
  encode(message: HelloSigned, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.supportDh) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(18).fork();
    for (const v of message.supportCipher) {
      writer.int32(v);
    }
    writer.join();
    if (message.cipherAlgorithm !== 0) {
      writer.uint32(24).int32(message.cipherAlgorithm);
    }
    if (message.publicKey !== undefined) {
      SignaturePublicKey.encode(message.publicKey, writer.uint32(34).fork()).join();
    }
    if (message.ephemeralKey !== undefined) {
      DHPublicKey.encode(message.ephemeralKey, writer.uint32(42).fork()).join();
    }
    if (message.additional.length !== 0) {
      writer.uint32(50).bytes(message.additional);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HelloSigned {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHelloSigned();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.supportDh.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportDh.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag === 16) {
            message.supportCipher.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportCipher.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.cipherAlgorithm = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.publicKey = SignaturePublicKey.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ephemeralKey = DHPublicKey.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.additional = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HelloSigned {
    return {
      supportDh: globalThis.Array.isArray(object?.supportDh)
        ? object.supportDh.map((e: any) => dHAlgorithmFromJSON(e))
        : [],
      supportCipher: globalThis.Array.isArray(object?.supportCipher)
        ? object.supportCipher.map((e: any) => cipherAlgorithmFromJSON(e))
        : [],
      cipherAlgorithm: isSet(object.cipherAlgorithm) ? cipherAlgorithmFromJSON(object.cipherAlgorithm) : 0,
      publicKey: isSet(object.publicKey) ? SignaturePublicKey.fromJSON(object.publicKey) : undefined,
      ephemeralKey: isSet(object.ephemeralKey) ? DHPublicKey.fromJSON(object.ephemeralKey) : undefined,
      additional: isSet(object.additional) ? bytesFromBase64(object.additional) : new Uint8Array(0),
    };
  },

  toJSON(message: HelloSigned): unknown {
    const obj: any = {};
    if (message.supportDh?.length) {
      obj.supportDh = message.supportDh.map((e) => dHAlgorithmToJSON(e));
    }
    if (message.supportCipher?.length) {
      obj.supportCipher = message.supportCipher.map((e) => cipherAlgorithmToJSON(e));
    }
    if (message.cipherAlgorithm !== 0) {
      obj.cipherAlgorithm = cipherAlgorithmToJSON(message.cipherAlgorithm);
    }
    if (message.publicKey !== undefined) {
      obj.publicKey = SignaturePublicKey.toJSON(message.publicKey);
    }
    if (message.ephemeralKey !== undefined) {
      obj.ephemeralKey = DHPublicKey.toJSON(message.ephemeralKey);
    }
    if (message.additional.length !== 0) {
      obj.additional = base64FromBytes(message.additional);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HelloSigned>, I>>(base?: I): HelloSigned {
    return HelloSigned.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HelloSigned>, I>>(object: I): HelloSigned {
    const message = createBaseHelloSigned();
    message.supportDh = object.supportDh?.map((e) => e) || [];
    message.supportCipher = object.supportCipher?.map((e) => e) || [];
    message.cipherAlgorithm = object.cipherAlgorithm ?? 0;
    message.publicKey = (object.publicKey !== undefined && object.publicKey !== null)
      ? SignaturePublicKey.fromPartial(object.publicKey)
      : undefined;
    message.ephemeralKey = (object.ephemeralKey !== undefined && object.ephemeralKey !== null)
      ? DHPublicKey.fromPartial(object.ephemeralKey)
      : undefined;
    message.additional = object.additional ?? new Uint8Array(0);
    return message;
  },
};

function createBaseHelloSignedBytes(): HelloSignedBytes {
  return {
    supportDh: [],
    supportCipher: [],
    cipherAlgorithm: 0,
    publicKey: new Uint8Array(0),
    ephemeralKey: new Uint8Array(0),
    additional: new Uint8Array(0),
  };
}

export const HelloSignedBytes: MessageFns<HelloSignedBytes> = {
  encode(message: HelloSignedBytes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.supportDh) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(18).fork();
    for (const v of message.supportCipher) {
      writer.int32(v);
    }
    writer.join();
    if (message.cipherAlgorithm !== 0) {
      writer.uint32(24).int32(message.cipherAlgorithm);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(34).bytes(message.publicKey);
    }
    if (message.ephemeralKey.length !== 0) {
      writer.uint32(42).bytes(message.ephemeralKey);
    }
    if (message.additional.length !== 0) {
      writer.uint32(50).bytes(message.additional);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HelloSignedBytes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHelloSignedBytes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.supportDh.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportDh.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag === 16) {
            message.supportCipher.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportCipher.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.cipherAlgorithm = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ephemeralKey = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.additional = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HelloSignedBytes {
    return {
      supportDh: globalThis.Array.isArray(object?.supportDh)
        ? object.supportDh.map((e: any) => dHAlgorithmFromJSON(e))
        : [],
      supportCipher: globalThis.Array.isArray(object?.supportCipher)
        ? object.supportCipher.map((e: any) => cipherAlgorithmFromJSON(e))
        : [],
      cipherAlgorithm: isSet(object.cipherAlgorithm) ? cipherAlgorithmFromJSON(object.cipherAlgorithm) : 0,
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      ephemeralKey: isSet(object.ephemeralKey) ? bytesFromBase64(object.ephemeralKey) : new Uint8Array(0),
      additional: isSet(object.additional) ? bytesFromBase64(object.additional) : new Uint8Array(0),
    };
  },

  toJSON(message: HelloSignedBytes): unknown {
    const obj: any = {};
    if (message.supportDh?.length) {
      obj.supportDh = message.supportDh.map((e) => dHAlgorithmToJSON(e));
    }
    if (message.supportCipher?.length) {
      obj.supportCipher = message.supportCipher.map((e) => cipherAlgorithmToJSON(e));
    }
    if (message.cipherAlgorithm !== 0) {
      obj.cipherAlgorithm = cipherAlgorithmToJSON(message.cipherAlgorithm);
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.ephemeralKey.length !== 0) {
      obj.ephemeralKey = base64FromBytes(message.ephemeralKey);
    }
    if (message.additional.length !== 0) {
      obj.additional = base64FromBytes(message.additional);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HelloSignedBytes>, I>>(base?: I): HelloSignedBytes {
    return HelloSignedBytes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HelloSignedBytes>, I>>(object: I): HelloSignedBytes {
    const message = createBaseHelloSignedBytes();
    message.supportDh = object.supportDh?.map((e) => e) || [];
    message.supportCipher = object.supportCipher?.map((e) => e) || [];
    message.cipherAlgorithm = object.cipherAlgorithm ?? 0;
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.ephemeralKey = object.ephemeralKey ?? new Uint8Array(0);
    message.additional = object.additional ?? new Uint8Array(0);
    return message;
  },
};

function createBaseHello(): Hello {
  return { version: 0, signed: undefined, signature: new Uint8Array(0) };
}

export const Hello: MessageFns<Hello> = {
  encode(message: Hello, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).int32(message.version);
    }
    if (message.signed !== undefined) {
      HelloSigned.encode(message.signed, writer.uint32(18).fork()).join();
    }
    if (message.signature.length !== 0) {
      writer.uint32(26).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Hello {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHello();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signed = HelloSigned.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Hello {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      signed: isSet(object.signed) ? HelloSigned.fromJSON(object.signed) : undefined,
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
    };
  },

  toJSON(message: Hello): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.signed !== undefined) {
      obj.signed = HelloSigned.toJSON(message.signed);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Hello>, I>>(base?: I): Hello {
    return Hello.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Hello>, I>>(object: I): Hello {
    const message = createBaseHello();
    message.version = object.version ?? 0;
    message.signed = (object.signed !== undefined && object.signed !== null)
      ? HelloSigned.fromPartial(object.signed)
      : undefined;
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseHelloBytes(): HelloBytes {
  return { version: 0, signed: new Uint8Array(0), signature: new Uint8Array(0) };
}

export const HelloBytes: MessageFns<HelloBytes> = {
  encode(message: HelloBytes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).int32(message.version);
    }
    if (message.signed.length !== 0) {
      writer.uint32(18).bytes(message.signed);
    }
    if (message.signature.length !== 0) {
      writer.uint32(26).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HelloBytes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHelloBytes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signed = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HelloBytes {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      signed: isSet(object.signed) ? bytesFromBase64(object.signed) : new Uint8Array(0),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
    };
  },

  toJSON(message: HelloBytes): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.signed.length !== 0) {
      obj.signed = base64FromBytes(message.signed);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HelloBytes>, I>>(base?: I): HelloBytes {
    return HelloBytes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HelloBytes>, I>>(object: I): HelloBytes {
    const message = createBaseHelloBytes();
    message.version = object.version ?? 0;
    message.signed = object.signed ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
